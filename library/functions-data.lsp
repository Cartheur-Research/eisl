;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; ISLisp Functions List 
;;;
;;; written by GOMI Hiroshi 2011
;;; Modifing by Kenichi Sasagawa 2021/4~
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; array
((BASIC-ARRAY-P obj) boolean "Check if obj is an array, a string, a vector")
((BASIC-ARRAY*-P obj) boolean "Check if obj is an array")
((GENERAL-ARRAY*-P obj) boolean "Check if obj is a general-array")
((CREATE-ARRAY dimensions initial-element +) <basic-array> "Generate an array")
((AREF basic-array z *) <object> "Extract the zth element of the array basic-array")
((GAREF general-array z *) <object> "Extract the zth element of the general-array")
((SET-AREF obj basic-array z *) <object> "Set the zth element obj of the array basic-array ")
((SET-GAREF obj general-array z *) <object> "Set the zth element obj of the array general-array")
((ARRAY-DIMENSIONS basic-array) <list> "Return a list of the dimensions of an array basic-array")

;;; char
((CHARACTERP obj) boolean "Check if obj is a string")
((CHAR= char1 char2) boolean "Check if the characters in char1 and char2 are equal")
((CHAR/= char1 char2) boolean "Check if the characters in char1 and char2 are not equal")
((CHAR< char1 char2) boolean "Check if the character code of char1 is larger than char2")
((CHAR> char1 char2) boolean "Check if the character code of char1 is smaller than char2")
((CHAR<= char1 char2) boolean "Check if the character code of char1 is greater than or equal to char2")
((CHAR>= char1 char2) boolean "Check if the character code of char1 is less than or equal to char2")

;;; cond
((error error-string obj *) <object> "エラーをシグナルする")
((cerror continue-string error-string obj *) <object> "継続可能なエラーをシグナルする")
((signal-condition condition continuable) <object> "コンディションを操作するためにシグナルする")
((ignore-errors form *) <object> "エラーが出ても無視する(特殊形式)")
((report-condition condition stream) <condition> "コンディション condition をストリーム stream にレポートする") 
((condition-continuable condition) <object> "継続可能かをチェックする")
((continue-condition condition value +) <object> "コンディションから継続する")
((with-handler handler form *) <object> "ハンドラを評価してフォームを実行する(特殊形式)")
((arithmetic-error-operation arithmetic-error) <function> "算術演算エラーのオペレータを返す")
((arithmetic-error-operands arithmetic-error) <list> "算術演算エラーのオペランドを返す")
((domain-error-object domain-error) <object>  "ドメインエラー domain-error で生成されたオブジェクトを返す")
((domain-error-expected-class domain-error) <class> "ドメインエラー domain-error で生成された望ましかったドメインを返す")
((parse-error-string parse-error) <string> "解析エラー parse-error で生成された文字列を返す")
((parse-error-expected-class parse-error) <class>  "解析エラー parse-error で生成された望ましいクラスを返す")
((simple-error-format-string simple-error) <string> "simple-error で生成された文字列を返す")
((simple-error-format-arguments simple-error) <list> "simple-error で生成された引数リストを返す")
((stream-error-stream stream-error) <stream> "ストリームエラー stream-error で生成されたストリームを返す")
((undefined-entity-name undefined-entity) <symbol> "未定義エンティティ undefined-entity で生成されたシンボルを返す")
((undefined-entity-namespace undefined-entity) <symbol> "未定義エンティティ undefined-entity で生成された名前空間を返す")

;;; control
((quote obj) <object> "obj の参照を返す(特殊形式)")
((setq var form) <object> "変数 var にフォーム form の評価結果を代入する(特殊形式)")
((setf place form) <object> "場所 place にフォーム form の評価結果を代入する(特殊形式)")
((let ((var form) *) body-form *) <object> "局所変数を定義し、その環境で実行する(特殊形式)")
((let* ((var form) *) body-form *) <object>  "letと同様であるが局所変数を順次束縛するところが異なる(特殊形式)")
((dynamic var) <object> "動的変数を宣言する(特殊形式)")
((setf (dynamic var) form) <object> "動的変数に値を代入する(特殊形式)")
((dynamic-let ((var form) *) body-form *) <object> "動的変数の一時的束縛をする(特殊形式)")
((if test-form then-form else-form+) <object> "条件の結果で分岐する(特殊形式)")
((cond (test form *) *) <object> "条件の結果で分岐する(特殊形式)")
((case keyform ((key *) form *) * (t form *)+) <object> "keyform の値によって多岐に分岐する(特殊形式)")
((case-using predform keyform ((key *) form *) * (t form *) +) <object> "case 文とほぼ同様であるが,述語関数 predform を比較に使う(特殊形式)")
((progn form*) <object> "順次実行を行なう(特殊形式)")
((while test-form body-form *) <null> "test-form が nil でない間 body-form を実行する(特殊形式)")
((for (iteration-spec *) (end-test result *) form *) <object> "iteration-spec で示された初期値とステッパを用い end-test が nil でない間繰り返し実行する(特殊形式)")
((block name form *) <object> "ブロックタグを付けて順次実行する(特殊形式)")
((return-from name result-form) transfers-control-and-data "name ブロックを抜ける(特殊形式)")
((catch tag-form form *) <object> "tag-form をキャッチし、form を実行する(特殊形式)")
((throw tag-form result-form) transfers-control-and-data "tag-form をスローする(特殊形式)")
((tagbody tagbody-tag * form *) <object> "tagbody-tagを付けて順次実行する(特殊形式)")
((go tagbody-tag) transfers-control "tag-bodyブロックに制御を移す(特殊形式)")
((unwind-protect form cleanup-form *) <object>  "formの評価を終了するときは必ず cleanup-form を実行する(特殊形式)")

;;; declare
((THE class-name form) <object> "form の実行結果のクラスを class-name と宣言する(特殊形式)")
((ASSURE class-name form) <object> "form の実行結果のクラスを class-name と主張する、異なる場合はエラーとなる(特殊形式)")
((CONVERT obj class-name) <object> "obj をクラス class-name に変換する(特殊形式)")

;;; files
((probe-file filename) boolean "filename のファイルが存在するかをチェックする")
((file-position stream) <integer> "stream の現在のファイル位置を返す")
((set-file-position stream z) <integer> " stream のファイル位置を z に設定する")
((file-length filename element-class) <integer> "filename のファイルを element-class のファイルとしてのサイズを返す")

;;; formeval
((functionp obj) boolean "obj が関数であるかをチェックする")
((function function-name) <function> "function-name を名前とする関数を返す(特殊形式)")
((lambda lambda-list form *) <function> "ラムダ式を生成する(特殊形式)")
((labels ((function-name lambda-list form *) *) body-forms *) <object>  "局所関数の束縛をする、順次束縛（再帰的定義が可能）である点が flet と異なる(特殊形式)")
((flet ((function-name lambda-list form *) *) body-forms *) <object>  "局所関数の束縛をする(特殊形式)")
((apply function obj * list) <object> "関数を適用する")
((funcall function obj *) <object> "関数を呼び出す")
((defconstant name form) <symbol> "定数を宣言する(特殊形式)")
((defglobal name form) <symbol> "広域変数を宣言する(特殊形式)")
((defdynamic name form) <symbol> "動的変数を宣言する(特殊形式)")
((defun function-name lambda-list form *) <symbol> "関数を定義する(特殊形式)")

;;; io
((read input-stream + eos-error-p + eos-value +) <object> "input-stream からS式として読む")
((read-char input-stream + eos-error-p + eos-value +) <object> "input-stream から1文字読む")
((preview-char input-stream + eos-error-p + eos-value +) <object>  "次に読み込む文字を返す（1文字先読み。ファイルポジションは変化しない）")
((read-line input-stream + eos-error-p + eos-value +) <object> "1行を文字列として読む")
((stream-ready-p input-stream) boolean "ストリームが読み込み可能になっているか")
((format output-stream format-string obj *) <null> "format-string に従って obj を出力する")
((format-char output-stream char) <null> "1文字出力する")
((format-float output-stream float) <null> "浮動小数点数として出力する")
((format-fresh-line output-stream) <null> "改行する")
((format-integer output-stream integer radix) <null> "整数として出力する")
((format-object output-stream obj escape-p) <null> "オブジェクトとして出力する")
((format-tab output-stream column) <null> "タブを出力する")
((read-byte input-stream eos-error-p + eos-value +) <integer> "バイトとして読む")
((write-byte z output-stream) <integer> "バイトとして書く")

;;; list
((CONSP obj) boolean "コンスかをチェックする")
((CONS obj1 obj2) <cons> "コンスを生成する")
((CAR cons) <object> "コンスの Car 部を取り出す")
((CDR cons) <object> "コンスの Cdr 部を取り出す")
((SET-CAR obj cons) <object> "コンスの Car 部にセットする")
((SET-CDR obj cons) <object> "コンスの Cdr 部にセットする")
((NULL obj) boolean "NULL かチェックする")
((LISTP obj) boolean "リストかチェックする")
((CREATE-LIST i initial-element +) <list> "長さ i 初期値 initial-element のリストを生成する")
((LIST obj *) <list> "obj を要素とするリストを生成する")
((REVERSE list) <list> "リストを逆順にする（元のリストは破壊しない）")
((NREVERSE list) <list> "リストを逆順にする（元のリストは破壊される）")
((APPEND list *) <list> "リストを連結する")
((MEMBER obj list) <list>  "リスト list に obj が含まれていれば、obj を先頭とする部分リストを返す")
((MAPCAR function list +) <list> "リスト list の要素に関数 function を実行し結果のリストを返す")
((MAPC function list +) <list>  "リスト list の要素に関数 function を実行し引数のリスト list を返す")
((MAPCAN function list +) <list>  "MAPCAR の操作を list を破壊して行なう")
((MAPLIST function list +) <list>  "リスト list の部分リストに関数 function を実行し、結果のリストを返す")
((MAPL function list +) <list>  "リスト list の部分リストに関数 function を実行し、引数リスト list を返す")
((MAPCON function list +) <list> "MAPLIST の操作を list を破壊して行なう")
((ASSOC obj association-list) <cons>  "連想リスト association-list に対して obj をキーとする値を返す")

;;; macro
((defmacro macro-name lambda-list form *) <symbol> "マクロを定義する(特殊形式)")

;;; misc
((IDENTITY obj) <object> "obj をそのまま返す")
((GET-UNIVERSAL-TIME) <integer> "ユニバーサルタイム（秒）を返す")
((GET-INTERNAL-RUN-TIME) <integer> "実行時間を返す")
((GET-INTERNAL-REAL-TIME) <integer> "経過時間を返す")
((internal-time-units-per-second) <integer> "1秒当たりのインターナルタイム単位を返す")

;;; number
((NUMBERP obj) boolean "obj が数型であるかをチェックする")
((PARSE-NUMBER string) <number> "文字列 string を解析して数型に変換する")
((= x1 x2) boolean "数値が等しいかをチェックする")
((/= x1 x2) boolean "数値が等しくないかをチェックする")
((>= x1 x2) boolean "数値 x1 が x2 以上であるかをチェックする")
((<= x1 x2) boolean "数値 x1 が x2 以下であるかをチェックする")
((> x1 x2) boolean "数値 x1 が x2 より大きいかをチェックする")
((< x1 x2) boolean "数値 x1 が x2 より小さいかをチェックする")
((+ x *) <number> "数値を加算する")
((* x *) <number> "数値を乗算する")
((- x y *) <number> "数値を減算する")
((QUOTIENT dividend divisor +) <number> "数値を除算する")
((RECIPROCAL x) <number> "数値を逆数にする")
((MAX x y *) <number> "数値の最大値を返す")
((MIN x y *) <number> "数値の最小値を返す")
((ABS x) <number> "数値の絶対値を返す")
((EXP x) <number> "数値の指数関数の値を返す")
((LOG x) <number> "数値の自然対数の値を返す")
((EXPT x1 x2) <number> "数値をべき乗する")
((SQRT x) <number> "数値の平方根を返す")
((SIN x) <number> "数値の sin 関数の値を返す")
((COS x) <number> "数値の cos 関数の値を返す")
((TAN x) <number> "数値の tan 関数の値を返す")
((ATAN x) <number> "数値の atan 関数の値を返す")
((ATAN2 x1 x2) <number> "数値の atan2 関数の値を返す")
((SINH x) <number> "数値の sinh 関数の値を返す")
((COSH x) <number> "数値の cosh 関数の値を返す")
((TANH x) <number> "数値の tanh 関数の値を返す")
((ATANH x) <number> "数値の atanh 関数の値を返す")
((FLOATP obj) boolean "obj が浮動小数点数であるかをチェックする")
((FLOAT x) <float> "数型 x を浮動小数点数に変換する")
((FLOOR x) <integer> "切り下げを行なう")
((CEILING x) <integer> "切り上げを行なう")
((TRUNCATE x) <integer> "0方向に丸める")
((ROUND x) <integer> "四捨五入を行なう")
((INTEGERP obj) boolean "obj が整数であるかをチェックする")
((DIV z1 z2) <integer> "数値を整数除算する")
((MOD z1 z2) <integer> "数値を剰余計算する")
((GCD z1 z2) <integer> "最大公約数を返す")
((LCM z1 z2) <integer> "最小公倍数を返す")
((ISQRT z) <integer> "整数平方根を返す")

;;; object
((defclass class-name (sc-name *) (slot-spec *) class-opt *) <symbol>  "クラス定義を行なう(特殊形式)")
((generic-function-p obj) boolean "obj が包括関数であるかをチェックする")
((defgeneric func-spec lambda-list option * method-desc *) <symbol>  "包括関数を定義する(特殊形式)")
((defmethod func-spec method-qualifier * parameter-profile form *) <symbol> "メソッド関数を定義する(特殊形式)")
((call-next-method) <object> "クラス優先順位の次のクラスのメソッドを呼び出す(特殊形式)")
((next-method-p) boolean "次のメソッドが存在するかをチェックする(特殊形式)")
((create class initarg * initval *) <object> "インスタンスオブジェクトを生成する(包括関数)")
((initialize-object instance initialization-list) <object> "オブジェクトの初期化を行なう")
((class-of obj) <class> "クラスを返す")
((instancep obj class) boolean "インスタンスオブジェクトであるかをチェックする")
((subclassp class1 class2) boolean "サブクラスであるかをチェックする")
((class class-name) <class> "名前 class-name のクラスを返す(特殊形式)")

;;; pred
((EQ obj1 obj2) boolean "obj1 と obj2 が eq であるかをチェックする")
((EQL obj1 obj2) boolean "obj1 と obj2 が eql であるかをチェックする")
((EQUAL obj1 obj2) boolean "obj1 と obj2 が equal であるかをチェックする")
((NOT obj) boolean "obj の否定を返す")
((AND form *) <object> "form の AND をする(特殊形式)")
((OR form *) <object> "form の OR をする(特殊形式)")

;;; seq
((LENGTH sequence) <integer> "列 sequence の長さを返す")
((ELT sequence z) <object> "列 sequence の z 番目の要素を返す")
((SET-ELT obj sequence z) <object> "列 sequence の z 番目に obj をセットする")
((SUBSEQ sequence z1 z2) sequence "列 sequence の z1 番目から z2 番目の部分列を取り出す")
((MAP-INTO destination function seq *) sequence  "列 sequence の要素に関数 function を適用して、その結果を列 destination に格納する")

;;; stream
((streamp obj) boolean "Predicate that is true for streams")
((open-stream-p obj) boolean "Predicate is true for open streams")
((input-stream-p obj) boolean "Predicate that is true for input streams")
((output-stream-p obj) boolean "Predicate that is true for output streams")
((standard-input) <stream> "Return the standard input stream")
((standard-output) <stream> "Return the standard output stream")
((error-output) <stream> "Return the standard error stream")
((with-standard-input stream-form form *) <object>  "Evaluate the forms form ... with standard-output set to the result of 'steram-form' (special form)")
((with-standard-output stream-form form *) <object> "Evaluate the forms form ... with standard-output set to the result of 'steram-form' (special form)")
((with-error-output stream-form form *) <object>  "Evaluate the forms form ... with standard-error set to the result of 'stream-form' (special form)")
((open-input-file filename element-class +) <stream> "Open the file 'filenam' as an input stream")
((open-output-file filename element-class +) <stream> "Open the file 'filename' as an output stream")
((open-io-file filename element-class +) <stream> "Open the file 'filename' for as an input/output stream")
((with-open-input-file (name file element-class +) form *) <object> "Evaluate 'form' with standard-input redirected from 'file' and afterwards close it (special form)")
((with-open-output-file (name file element-class +) form *) <object> "Evaluate 'form' with standard-output redirected to 'file' and afterwards close it (special form)")
((with-open-io-file (name file element-class +) form *) <object> "Evaluate 'form' with both standard-input and standard-output streams redirected to/from 'file' and afterwards close it (special form)")
((close stream) implementation-defined "Close a stream")
((create-string-input-stream string) <stream> "Create a string input stream")
((create-string-output-stream) <stream> "Create a string output stream")
((get-output-stream-string stream) <string> "Return a string containing the output that was sent to a string output stream")

;;; string
((STRINGP obj) boolean "Predicate that is true for strings")
((CREATE-STRING i initial-element+) <string> "Create a string of length 'i' filled with 'initial-element'")
((STRING= string1 string2) quasi-boolean "Are two strings equal?")
((STRING/= string1 string2) quasi-boolean "Are two strings not equal?")
((STRING< string1 string2) quasi-boolean "Is 'string1' before 'string2' in sort order?")
((STRING> string1 string2) quasi-boolean "Is 'string1' after 'string2' in sort order?")
((STRING>= string1 string2) quasi-boolean "Is 'string1' after or equal to 'string2' in sort order?")
((STRING<= string1 string2) quasi-boolean "Is 'string1' before or equal to 'string2' in sort order?")
((CHAR-INDEX character string start-position +) <object> "Return the position where 'character' occurs in 'string'")
((STRING-INDEX substring string start-position +) <object> "Return the position where 'substring' occurs in 'string'")
((STRING-APPEND string *) <string> "Concatenate the strings string ...")

;;; symbol
((SYMBOLP obj) boolean "Predicate that is true for <symbol> objects")
((PROPERTY symbol property-name obj +) <object> "Return a property of a symbol")
((SET-PROPERTY obj symbol property-name) <object> "Set a property of a symbol")
((REMOVE-PROPERTY symbol property-name) <object> "Remove a property from a symbol")
((GENSYM) <symbol> "Create an anonymous symbol")

;;; vector
((BASIC-VECTOR-P obj) boolean "Predicate that is true for <basic-vector> objects")
((GENERAL-VECTOR-P obj) boolean "Predicate that is true for <general-vector> objects")
((CREATE-VECTOR i initial-element +) <general-vector>  "Create a vector of length 'i', with each element initialised to 'initial-element'")
((VECTOR obj *) <general-vector> "Create a vector from the elements obj ...")

;;; OKI ISlisp
((load file) T "Load 'file' (extension)" )
((time form) <object> "Show the time to evaluate 'form' (special form) (extension)")
;((room) <null> "現在のメモリ使用状況を表示する（拡張）")
((eval form) <object> "Evaluate 'form' (extension)")
;((list* obj *) <list>  "関数 list とほぼ同じであるが最後の引数を最後のコンスの CDR 部に格納する（拡張）")
;((append* obj *) <list>  "関数 append とほぼ同じであるが最後の引数を最後のコンスの CDR 部に格納する（拡張）")
;((nth n list) <object> "list の n 番目の要素を返す（拡張）") 
;((compile fun) boolean "関数 fun をコンパイルする(拡張)")
((compile-file file) boolean "Compile 'file' (extension)")
;((compile-files dst-fname src-fname *) boolean  "src-fname の複数のファイルを dst-fname のファイルにコンパイルする(拡張)")
;((descibe obj) idef "obj の内容を表示する（拡張）")
((gbc) <null> "Force garbage collection (extension)")
;((write object stream +) <null> "object を stream に表示する(拡張)")
((quit) transfers-control "Exit the ISLisp interpreter (extension)")
