
;; pretty printer for ISLisp
;; written by kenichi sasagawa
(defconstant width 100)
(defconstant long-element 15)
(defconstant long-element-sum 60)
(defconstant defglobal-long-element 50)
(defconstant single-comment-margin 30)
(defglobal buffer nil)
(defglobal input-stream (standard-input))
(defglobal output-stream (standard-output))
(defglobal otomo nil)
(defun dropstring (str n)
    (substring str n (- (length str) 1)) )

(defun substring (str m n)
    (for ((i m (+ i 1))
          (str1 "") )
         ((> i n)
          str1 )
         (setq str1 (string-append str1 (create-string 1 (elt str i))))))

;; to test pp1 in standard-input
(defun pp (x)
    (pp1 x 0) )

;; pretty-print if asdata is given, pp1 doesn't care syntax. 
(defun pp1 (x lm :rest asdata)
    (cond ((atom x) (pp-atom x))
          ((consp x)
           (cond ((or (quote-p x) (backquote-p x) (unquote-p x)) (pp-quote x lm))
                 ((unquote-splicing-p x) (pp-unquote-splicing x lm))
                 ((and (null asdata) (eq (car x) 'cond)) (pp-cond x lm))
                 ((and (null asdata) (eq (car x) 'case)) (pp-case x lm))
                 ((and (null asdata) (eq (car x) 'if)) (pp-if x lm))
                 ((and (null asdata) (eq (car x) 'let)) (pp-let x lm))
                 ((and (null asdata) (eq (car x) 'let*)) (pp-let* x lm))
                 ((and (null asdata) (eq (car x) 'for)) (pp-for x lm))
                 ((and (null asdata) (eq (car x) 'defun)) (pp-defun x lm))
                 ((and (null asdata) (eq (car x) 'defpublic)) (pp-defun x lm))
                 ((and (null asdata) (eq (car x) 'defgeneric)) (pp-defun x lm))
                 ((and (null asdata) (eq (car x) 'defmacro)) (pp-defun x lm))
                 ((and (null asdata) (eq (car x) 'defmodule)) (pp-defmodule x lm))
                 ((and (null asdata) (eq (car x) 'defglobal)) (pp-defglobal x lm))
                 ((and (null asdata) (eq (car x) 'defconstant)) (pp-defglobal x lm))
                 ((and (null asdata) (eq (car x) 'defdynamic)) (pp-defglobal x lm))
                 ((and (null asdata) (eq (car x) 'block)) (pp-block x lm))
                 ((and (null asdata) (eq (car x) 'while)) (pp-block x lm))
                 ((and (null asdata) (eq (car x) 'dotimes)) (pp-block x lm))
                 ((and (null asdata) (eq (car x) 'dolist)) (pp-block x lm))
                 ((and (null asdata) (eq (car x) 'lambda)) (pp-lambda x lm))
                 ((and (null asdata) (eq (car x) 'labels)) (pp-labels x lm))
                 ((and (null asdata) (eq (car x) 'flet)) (pp-labels x lm))
                 ((and (null asdata) (long-element-p x)) (setq otomo t) (pp-long-element x lm))
                 ((< (+ (flatsize x) lm) width) (pp-flat x lm))
                 (t (setq otomo t) (pp-indent x lm))))))

;; write symbol number string object
(defun pp-atom (x)
    (if (stringp x)
        (format output-stream "\"~A\"" x)
        (format output-stream "~A" x) ))

;; write string as text
(defun pp-text (x)
    (format output-stream "~A" x) )

;; write cons as flat
(defun pp-flat (x lm)
    (pp-text "(")
    (for ((s x (cdr s)))
         ((null s)
          (pp-text ")") )
         (pp1 (car s) lm)
         (if (not (null (cdr s))) ;not end element
             (space 1))))
;; write cons with indent
(defun pp-indent (x lm)
    (pp-text "(")
    (for ((s x (cdr s)))
         ((null s)
          (cond ((= (length x) 0) (pp-text ")"))
               (otomo (pp-atom ")"))
               (t (setq otomo t) (pp-text " )")) )
          (if (= lm 0)
             (newline 0)) )
         (pp1 (car s) (+ lm 1))
         (if (not (null (cdr s))) ;not end element
             (newline (+ lm 1)))))


;; write each syntax but 
;; if it is quote,backquote,untuote,unquote-splicing 
;; pp-quote or pp-unquote-splicing
(defun pp-special (x fun lm)
    (cond ((quote-p x) (pp-quote x lm))
          ((backquote-p x) (pp-quote x lm))
          ((unquote-p x) (pp-quote x lm))
          ((unquote-splicing-p x) (pp-quote x lm)) ))


;; syntax cond
(defun pp-cond (x lm)
    (pp-atom "(COND ")
    (pp-cond1 