(import "test")
($eval (defglobal *call-tree* '()))
($eval 
 (defun add-call-tree (x)
   (setq *call-tree* (cons x *call-tree*))))

($eval (defglobal *call-tree* '()))
($eval (defglobal *gf1* '()))
($eval (defglobal *gf2* '()))
($eval (defglobal *gf3* '()))
($eval (defglobal *gf4* '()))
($eval 
 (defgeneric foo-33 (x)
   ;;
   (:method ((x <integer>))
	    (add-call-tree 'i-primary-1)
	    (setq *gf1* (lambda (y) (list 'i-primary-1 x y)))
	    (call-next-method)
	    (add-call-tree 'i-primary-2)
	    (setq *gf2* (lambda (y) (list 'i-primary-2 (call-next-method) y)))
	    'i-primary-2)
   (:method :around ((x <integer>))
	    (add-call-tree 'i-around-1)
	    (if (next-method-p)
		(call-next-method))
	    (add-call-tree 'i-around-2))
   (:method :before ((x <integer>))
	    (add-call-tree 'i-before))
   (:method :after ((x <integer>))
	    (add-call-tree 'i-after))
   ;;
   (:method ((x <number>))
	    (add-call-tree 'n-primary-1)
	    (setq *gf3* (lambda (y) (list 'n-primary-1 x y)))
	    (call-next-method)
	    (setq *gf4* (lambda (y) (list 'n-primary-2 (call-next-method) y)))
	    (add-call-tree 'n-primary-2))
   (:method :around ((x <number>))
	    (add-call-tree 'n-around-1)
	    (if (next-method-p)
		(call-next-method))
	    (add-call-tree 'n-around-2))
   (:method :before ((x <number>))
	    (add-call-tree 'n-before))
   (:method :after ((x <number>))
	    (add-call-tree 'n-after))
   ;;
   (:method (x)
	    (add-call-tree 'innermost))
   ))
($eval
 (defun cf1 ()
  (setq *call-tree* '())
  (funcall *gf1* 100)))
($eval 
 (defun cf2 ()
   (setq *call-tree* '())
   (funcall *gf2* 100)))
($eval 
 (defun cf3 ()
   (setq *call-tree* '())
   (funcall *gf3* 100)))
($eval
 (defun cf4 ()
   (setq *call-tree* '())
   (funcall *gf4* 100)))
($eval (foo-33 1))
($test (cf1) (i-primary-1 1 100) equal)
($test (cf2) (i-primary-2 (n-primary-2 innermost n-primary-1) 100) equal)
($test (cf3) (n-primary-1 1 100) equal)
;($test (cf4) (n-primary-2 (innermost) 100) equal)
